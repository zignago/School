/*
 * This vector class is a simplified version of the std::vector
 * DO NOT EDIT THIS FILE!! Otherwise, you risk getting a 0.
 * To see the function specifications in more detail, check the cppreference
    link in the resources section.
 * Make sure to test your vector with multiple types:
    (e.g., int, char, long, etc.)

 * TODO 1: implement the get_identity and MySwap functions in MyVector.hpp
 * TODO 2: implement the MyVector-related functions in MyVector.hpp
 * TODO 3: thoroughly test your MyVector class to ensure proper functional
    behaviors
 */

#ifndef MYVECTOR_H
#define MYVECTOR_H

#include <iostream>
#include <stdexcept>
#include <string>

using std::cout;
using std::cerr;
using std::endl;
using std::cin;
using std::string;

/*
* the your (the student authorâ€™s) Campus Username
*/
void get_identity(string &my_id);


// Purpose: Swaps two elements (including a vector).
// Parameters: a, b: the list elements themselves to be swapped
// Note: a and b can be any parameters,
//  e.g., swap(list_obj[2], list_obj[1]);
//
// This one is similar to std::swap
//  https://en.cppreference.com/w/cpp/algorithm/swap
// On all assignments AFTER this one (e.g., on pa05), you can use std::swap
template <typename T>
void MySwap(T &a, T &b);


template <typename T>
class MyVector
{
    private:
        T *m_data = nullptr;
        int reserved_size; // capacity; initial value should be 0
        int data_size; // the count of current number of data elements

    public:
        // Just a simple default constructor.
        MyVector();

        ~MyVector();

        // Make sure this does a deep copy
        MyVector<T> & operator=(const MyVector<T> &source);

        // Make sure this does a deep copy
        MyVector(const MyVector<T> &source);

        // Returns the element of the array by reference, so it can be read or
        //  written.
        T & operator[](int i);

        // Purpose: Returns the element stored at the index by reference
        // Parameters: index - The location of the element to be returned.
        // This one should throw an std::out_of_range exception if and when
        //  out-of-bounds
        T & at(int index);

        // Purpose: Returns the element stored at the front of the vector
        T & front();

        // Purpose: Returns the element stored at the back of the vector
        T & back();

        // Purpose: Returns the MAXIMUM number of elements that can be stored in
        //  the current Vector
        int capacity();

        // Purpose: Grow the MyVector capacity to ensure that there is enough
        //    room for a specific number of elements??
        // Parameters: new_cap - the new amount of space to be reserved
        // Postconditions: Increases MyVector's current capacity to new_cap
        //    IF new_cap > current capacity. By default, you should DOUBLE the
        //    capacity of the current array when it fills up.
        // NOTE 1: reserve SHOULD NOT do the actual checking of whether it's full;
        //    this should be done within other functions as their operations
        //    change the data size.
        // NOTE 2: A special case is needed to grow the initial MyVector to 1,
        //    then 2, 4, etc. since the default capacity is 0
        void reserve(int new_cap);

        // If your array hits the point at which its data size is LESS THAN 1/4
        //    of the capacity, this function should be called.
        // It should shrink MyVector such that it is 2x as big as the data size.
        // NOTE: shrink_to_fit SHOULD NOT do the actual checking of 1/4 full
        void shrink_to_fit();

        // Fills MyVector with count of T value (e.g., assign(5, a) would be
        //    [a, a, a, a, a])
        // This REPLACES the current array.
        void assign(int count, const T &value);

        // Purpose: Clears the MyVector
        // Postconditions: current size set to 0, capacity size set to 0, and
        //    elements are deallocated and data is set to nullptr
        void clear();

        // Purpose: appends the value x to the end of an MyVector
        // Parameters: x is value to be added to MyVector
        // Postconditions: current size is incremented by 1; if max size is
        //     reached, the storage array should expand to have a bigger reserve
        void push_back(const T &x);

        // Removes the last element of the vector
        void pop_back();

        // Purpose: inserts the value x at the position i, i.e. before the value
        //          currently at i in MyVector
        // Parameters: x is value to be added to MyVector
        //             i is the position to insert x at
        // Postconditions: current size is incremented by 1; if max size is
        //     reached, the storage array should expand to have a bigger reserve
        void insert(int i, const T &x);

        // Purpose: Removes the element at index i in the array
        // Parameters: i, the index of the element to remove
        // Postconditions: if the size of the list is greater than 0
        //     size is decremented by one after the removal.
        //     if the size of the list is less than 1/4 the max size after the
        //     update, shrink the storage array
        void erase(int i);

        // Returns the size of the actual data stored in the array list
        int size();

        // This is designed to partially mimic the behavior of iterators.
        int begin()
        {
            return 0;
        }

        // This is designed to partially mimic the behavior of iterators.
        int end()
        {
            return size();
        }
};


// We're giving you this one, but it relies on you having implemented the .at()
//  and .size() member functions first.
template <typename T>
std::ostream & operator<<(std::ostream &out, MyVector<T> &my_list)
{
    out << "[ ";

    for(int i = 0; i < my_list.size(); i++)
    {
        out << my_list.at(i) << ", ";
    }

    out << "]";

    return out;
}


#include "MyVector.hpp"

#endif
